# 3장. 노드 기능 알아보기

## 3.1 REPL 사용하기

자바스크립트는 스크립트 언어로, 미리 컴파일하지 않아도 바로 코드를 실행할 수 있다.<br/>
노드도 비슷한 콘솔을 제공하며, REPL(Read, Eval, Print, Loop)라고 한다.

사용방법은 다음과 같다.<br/>
맥과 리눅스는 터미널에서 `node`를 입력한다.<br/>
VS Code는 터미널에서 `Ctrl` + `\`\`

프롬프트가 > 모양으로 바뀐 후, 자바스크립트 코드 입력이 가능하다.<br/>

REPL을 종료하기 위해서는 `Ctrl` + `C`를 두번 누르거나, REPL 창에 `.exit`을 입력한다.

REPL은 한두 줄 짜리 코드를 테스트 해보는 용도 정도로 사용할 수 있다.

<br/>

## 3.2 JS 파일 실행하기

당연하게도, 자바스크립트 파일을 만들어 실행할 수 있다.<br/>
파일은 아무 폴더(디렉터리) 안에 만들어도 된다.

콘솔에서 node [자바스크립트 파일 경로]로 실행한다. (확장자 생략 가능)<br/>
REPL이 아니라 터미널에서 입력해야 한다.

<br/>

## 3.3 모듈로 만들기

노드는 코드를 모듈로 만들 수 있다는 점에서 브라우저의 자바스크립트와는 다르다.<br/>
모듈이란 특정 기능을 하는 함수나 변수들의 집합을 말한다.<br/>
모듈로 만들어두면 여러 프로그램에서 모듈을 재사용할 수 있다. (자바스크립트의 함수와 비슷한 기능)

노드에서는 두 가지 형식의 모듈을 사용하는데, 하나는 CommonJS 모듈이고 하나는 ECMAScript 모듈.

<br/>

### 3.3.1 CommonJS 모듈

CommonJS 모듈은 표준이 아니지만, 표준이 만들어지기 이전부터 쓰였기 때문에 가장 많이 쓰인다.

실질적으로 모듈이 사용되는 형식은 다음과 같다.

```javascript
// var.js
const odd = "홀수";
const even = "짝수";

module.exports = {
  odd,
  even,
};
```

```javascript
// func.js
const { odd, even } = require("./var");

function checkOddOrEven(num) {
  return num % 2 ? odd : even;
}

exports.checkOddOrEven = checkOddOrEven;
```

```javascript
// index.js
const checkNumber = require("./func");

checkNumber(10);
```

module 객체가 아닌 exports 객체로도 모듈을 만들 수 있다.<br/>
exports 객체에 값을 넣으면 module.exports에도 함수가 들어간다.

export 객체는 module.exports 객체를 참조하고 module.exports 객체는 {} 객체를 참조한다.

중요한 것은 exports와 module.exports 둘의 참조관계가 깨지지 않도록 주의 해야한다.<br/>
이 떄문에 한 모듈에 두 가지 방식을 동시에 사용하지는 않는다.

````md
`노드에서의 this`

```javascript
console.log(this); // {}
console.log(this === module.exports); // true
console.log(this === exports); // true

function whatIsThis() {
  console.log(this === exports); // false
  console.log(this === global); // true
}
whatIsThis();
```

다른 부분은 브라우저의 자바스크립트와 동일하지만,<br/>
최상위 스코프에 존재하는 this는 module.exports 또는 exports 객체를 가리킨다.

또한, 함수 선언문 내부의 this는 global 객체를 가리킨다.
````

```javascript
// dep1.js
const dep2 = require("./dep2");
console.log("require dep2", dep2);

module.exports = () => {
  console.log("dep2", dep2);
};
```

```javascript
// dep2.js
const dep1 = require("./dep1");
console.log("require dep1", dep1);

module.exports = () => {
  console.log("dep1", dep1);
};
```

```javascript
// dep-run.js
const dep1 = require("./dep1");
const dep2 = require("./dep2");

dep1();
dep2();
```

```md
**$ node dep-run**
require dep1 {}<br/>
require dep2 [Function (anonymous)]<br/>
dep2 [Function (anonymous)]<br/>
dep1 {}

Warning: -
```

이처럼 순환 참조가 발생할 경우, 순환 참조 대상을 빈 객체로 만든다.<br/>
순환 참조가 발생하지 않도록 구조를 잘 잡는 것이 중요하다.

<br/>

### 3.3.2 ECMAScript 모듈

공식적인 자바스크립트 표준 모듈.<br/>
사용법은 익숙하기 때문에 생략.

<br/>

### 3.3.3 다이내믹 임포트

CommonJS 모듈 에서는 다이내믹 임포트가 가능하지만 ES 모듈에서는 불가능하다.<br/>

```javascript
const TARGET = false;

if (TARGET) {
  require("/func");
}
```

위와같은 조건부 모듈 불러오기가 다이내믹 임포트.<br/>
그렇다면 ES 모듈에서는 어떠한 방식으로 다이내믹 임포트를 구현하는가

```javascript
const TARGET = true;

if (TARGET) {
  const m1 = await import("./func.mjs");
  const m2 = await import("./var.mjs");
}
```

import라는 `함수`를 사용해서 모듈을 동적으로 불러올 수 있다.<br/>
import는 Promise를 반환하기에 await이나 then을 붙여 사용해야 한다.

위의 코드에서는 async를 사용하지 않았는데,<br/>
ES 모듈 최상위 스코프에서는 async 함수 없이도 await을 할 수 있다.

<br/>

### 3.3.4 \_\_filename, \_\_dirname

노드에서는 파일 사이에 모듈 관계가 있는 경우가 많기 때문에<br/>
현재 파일의 경로나 파일명을 알아야 하는 경우가 있다.

\_\_filename, \_\_dirname 키워드를 통해 경로에 대한 정보를 제공한다.

사용되는 OS 환경에 따라 폴더 경로 구분자가 /혹은 \로 달라지기 때문에<br/>
보통은 이를 해결해주는 path 모듈과 함께 사용한다.

ES 모듈에서는 \_\_filename, \_\_dirname을 사용할 수 없기 떄문에,<br/>
import.meta.url로 경로를 가져와서 사용한다.

<br/>

## 3.4 노드 내장 객체 알아보기

<br/>

## 3.5 노드 내장 모듈 사용하기

<br/>

## 3.6 파일 시스템 접근하기

<br/>

## 3.7 이벤트 이해하기

<br/>

## 3.8 예외 처리하기

<br/>

## 3.9 함께 보면 좋은 자료

<br/>
