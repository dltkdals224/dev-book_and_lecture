# 섹션 8. 비동기-동시성 프로그래밍 1

```javascript
const curry = (func) => {
  return (a, ..._) => {
    return _.length ? func(a, ..._) : (..._) => func(a, ..._);
  };
};

const map = curry((func, iter) => {
  let res = [];
  iter = iter[Symbol.iterator]();
  let cur;
  while (!(cur = iter.next()).done) {
    const target = cur.value;
    res.push(func(target));
  }
  return res;
});

const filter = curry((func, iter) => {
  let res = [];
  iter = iter[Symbol.iterator]();
  let cur;
  while (!(cur = iter.next()).done) {
    const target = cur.value;
    if (func(target)) {
      res.push(target);
    }
  }
  return res;
});

const reduce = curry((func, acc, iter) => {
  if (!iter) {
    iter = acc[Symbol.iterator]();
    acc = iter.next().value;
  } else {
    iter = iter[Symbol.iterator]();
  }
  let cur;
  while (!(cur = iter.next()).done) {
    const target = cur.value;
    acc = func(acc, target);
  }
  return acc;
});

//
const L = {};
L.map = curry(function* (func, iter) {
  iter = iter[Symbol.iterator]();
  let cur;
  while ((cur = iter.next()).done) {
    const target = cur.value;
    yield func(target);
  }
});

L.filter = curry(function* (func, iter) {
  iter = iter[Symbol.iterator]();
  let cur;
  while ((cur = iter.next()).done) {
    const target = cur.value;
    if (func(target)) {
      yield target;
    }
  }
});

const go = (...args) => {
  return args.reduce((previousFunc, currentFunc) => {
    return currentFunc(previousFunc);
  });
};

const pipe = (func, ...funcs) => {
  return (...args) => {
    return go(func(...args), ...funcs);
  };
};

const take = curry((length, iter) => {
  let res = [];
  iter = iter[Symbol.iterator]();
  let cur;
  while (!(cur = iter.next()).done) {
    const target = cur.value;
    res.push(target);
    if (res.length === length) {
      return res;
    }
  }
  return res;
});

const find = curry((func, iter) =>
  go(iter, L.filter(func), take(1), ([target]) => target)
);
```

## callback과 Promise

```javascript
function addByCallback(target, callback) {
  setTimeout(() => callback(target + 1), 1000);
}

addByCallback(1, (res) => {
  addByCallback(res, (res) => {
    addByCallback(res, (res) => {
      addByCallback(res, (res) => {
        console.log("callback pattern", res);
      });
    });
  });
});

// Promise의 경우는 매개변수로 callback 함수가 필요 없음.
function addByPromise(target) {
  // return 으로 값을 다룬다는게 중요한 부분.
  return new Promise((resolve) => setTimeout(() => resolve(target + 10), 1000));
}

addByPromise(10)
  .then(addByPromise)
  .then(addByPromise)
  .then(addByPromise)
  .then((res) => console.log("promise pattern", res));
```

<br/>

## 비동기를 값으로 만드는 Promise

가장 중요한 차이는 then의 연속을 통해서 값을 꺼내볼 수 있다는 것이 아니고,<br/>
비동기 상황을 일급 값으로 다룬다는 것.

Promise는 pending, fulfilled, rejected 로 구성되어 있음.

```javascript
const callbackRes = addByCallback(1, (res) => {
  addByCallback(res, (res) => {
    addByCallback(res, (res) => {
      addByCallback(res, (res) => {
        console.log("callback pattern", res);
      });
    });
  });
});

const promiseRes = addByPromise(10)
  .then(addByPromise)
  .then(addByPromise)
  .then(addByPromise)
  .then((res) => console.log("promise pattern", res));

console.log(callbackRes); // undefined
console.log(promiseRes); // Promise { <pending> }

// addByCallback 함수와 달리 Promise를 통해 후처리를 이어갈 수 있음
```

<br/>

## 값으로서의 Promise 활용

```javascript
const delay = (target) => {
  return new Promise((resolve) => {
    return setTimeout(() => {
      resolve(target);
    }, 1000);
  });
};
const addOne = (a) => a + 1;

const checkPromise = (target, func) => {
  if (target instanceof Promise) {
    return target.then(func);
  }
  return func(target);
};

const res1 = checkPromise(10, addOne);
console.log(res1); // 11
const res2 = checkPromise(delay(10), addOne);
res2.then(console.log); // 11

checkPromise(checkPromise(10, addOne), console.log); // 11
checkPromise(checkPromise(delay(10), addOne), console.log); // 11
```

<br/>

## 합성 관점에서의 Promise와 모나드

```javascript
const funcG = (target) => target + 1;
const funcF = (target) => target * target;

console.log(funcF(funcG(1))); // 4
console.log(funcF(funcG())); // NaN(안전한 합성이 이루어지지 않음)

// 이런 것들을 해결해주는게 모나드

[1]
  .map(funcG)
  .map(funcF)
  .forEach((result) => console.log(result)); // forEach를 통해서 외부 세상의 값 변경을 이루어냄.

// 이렇게 하면 장점이 무엇?

[]
  .map(funcG) // 이 부분에서 함수가 더 이상 진행되지 않음.
  .map(funcF)
  .forEach((result) => console.log(result)); // NaN 으로 출력되지 않음.

// 이해를 돕기 위해 Array.of() 사용.
Array.of(1)
  .map(funcG)
  .map(funcF)
  .forEach((result) => console.log(result)); // forEach를 통해서 외부 세상의 값 변경을 이루어냄.

// Promise는 비동기적으로 일어나는 상황을 안전하게 합성하기 위한 도구.
Promise.resolve()
  .then(funcG)
  .then(funcF)
  .then((result) => console.log(result)); // NaN
// 안에 어떠한 값이 있는지 없는지에 대해서 안전한 상황을 추구하는게 아님
```

<br/>

## Kleisli Composition 관점에서의 Promise

들어오는 인자가 잘못되어서 함수에서 에러가 발생하거나<br/>
혹은 정확한 인자가 전달 되었어도, 외부에 대한 의존 때문에 정확한 결과를 전달할 수 없을때 에러가 발생<br/>
하는 상황들을 해결하기 위한 목적으로써의 함수 합성

f(g(x)) === f(g(x))<br/>
실무에서, 좌변과 우변에서의 g(x)가 다르게 평가되는 경우가 발생할 수 있음(합성이 성립되지 않음).<br/>
이러한 상황에서도 안전한 합성을 이룰 수 있도록 하는 방법이 Cleisli Composition

f(g(x)) === g(x)<br/>
에러가 발생한 경우, g가 리턴하는 값이 f를 합성하더라도 마치 합성을 하지 않은 것처럼 동작하게 되는 것.

<br/>

## go, pipe, reduce에서 비동기 제어

<br/>

## 3promise.then의 중요한 규칙

<br/>
