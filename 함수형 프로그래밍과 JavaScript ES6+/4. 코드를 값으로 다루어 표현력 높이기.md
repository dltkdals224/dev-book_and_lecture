# 섹션 4. 코드를 값으로 다루어 표현력 높이기

## go

코드를 값으로 다루어 표현력을 높이는 한가지 방법.

```javascript
// go함수 만들어보기 (go함수는 ECMAScript 내장 함수가 아님)
const go = (...args) => {
  return args.reduce((previousFunc, currentFunc) => {
    return currentFunc(previousFunc);
  });
};
```

<br/>

## pipe

```javascript
const go = (...args) => {
  return args.reduce((previousFunc, currentFunc) => {
    return currentFunc(previousFunc);
  });
};

// pipe함수 만들어보기 (내부적으로 go를 사용)
const pipe = (func, ...funcs) => {
  return (...args) => {
    return go(func(...args), ...funcs);
  };
};
```

<br/>

## go를 사용하여 읽기 좋은 코드로 만들기

```javascript
const products = [
  { name: "반팔티", price: 15000 },
  { name: "긴팔티", price: 20000 },
  { name: "바지", price: 25000 },
  { name: "후드티", price: 30000 },
];

const myMap = (func, iter) => {
  let res = [];
  for (const target of iter) {
    res.push(func(target));
  }
  return res;
};

const myFilter = (func, iter) => {
  let res = [];
  for (const target of iter) {
    if (func(target)) {
      res.push(target);
    }
  }
  return res;
};

const myReduce = (func, acc, iter) => {
  if (!iter) {
    iter = acc[Symbol.iterator]();
    acc = iter.next().value;
  }
  for (const target of iter) {
    acc = func(acc, target);
  }
  return acc;
};

const go = (...args) => {
  return args.reduce((previousFunc, currentFunc) => {
    return currentFunc(previousFunc);
  });
};

// 이런 구조 때문에 map, filter, reduce를 별도로 함수로 만들어 작성해옴.
go(
  products,
  (products) => myMap((product) => product.price, products),
  (prices) => myFilter((price) => price < 25000, prices),
  (prices) => myReduce((a, b) => a + b, prices),
  console.log // 35000
);

// 비교를 위한 이전 코드
console.log(
  products
    .map((obj) => {
      return obj.price;
    })
    .filter((price) => {
      return price < 25000;
    })
    .reduce((a, b) => {
      return a + b;
    })
); // 35000
```

<br/>

## go+curry를 사용하여 더 읽기 좋은 코드로 만들기

```javascript
const products = [
  { name: "반팔티", price: 15000 },
  { name: "긴팔티", price: 20000 },
  { name: "바지", price: 25000 },
  { name: "후드티", price: 30000 },
];

const curry = (func) => {
  return (a, ..._) => {
    return _.length ? func(a, ..._) : (..._) => func(a, ..._);
  };
};
// 기존 함수들에 curry를 적용함으로써,
// 인자를 하나 받으면 이후 인자를 기다리는 함수를 리턴하도록 바꿀 수 있음.

const myMap = curry((func, iter) => {
  let res = [];
  for (const target of iter) {
    res.push(func(target));
  }
  return res;
});

const myFilter = curry((func, iter) => {
  let res = [];
  for (const target of iter) {
    if (func(target)) {
      res.push(target);
    }
  }
  return res;
});

const myReduce = curry((func, acc, iter) => {
  if (!iter) {
    iter = acc[Symbol.iterator]();
    acc = iter.next().value;
  }
  for (const target of iter) {
    acc = func(acc, target);
  }
  return acc;
});

const go = (...args) => {
  return args.reduce((previousFunc, currentFunc) => {
    return currentFunc(previousFunc);
  });
};

// 기존 go
go(
  products,
  (products) => myMap((product) => product.price, products),
  (prices) => myFilter((price) => price < 25000, prices),
  (prices) => myReduce((a, b) => a + b, prices),
  console.log // 35000
);

// 최종 함수 모형
go(
  products,
  (products) => myMap((product) => product.price)(products),
  (prices) => myFilter((price) => price < 25000)(prices),
  (prices) => myReduce((a, b) => a + b)(prices),
  console.log // 35000
);
// 최종 함수 모형 (생략 형태)
go(
  products,
  myMap((product) => product.price),
  myFilter((price) => price < 25000),
  myReduce((a, b) => a + b),
  console.log // 35000
);
```

<br/>

## 함수 조합으로 함수 만들기

```javascript
const products = [
  { name: "반팔티", price: 15000 },
  { name: "긴팔티", price: 20000 },
  { name: "바지", price: 25000 },
  { name: "후드티", price: 30000 },
];

const curry = (func) => {
  return (a, ..._) => {
    return _.length ? func(a, ..._) : (..._) => func(a, ..._);
  };
};

const myMap = curry((func, iter) => {
  let res = [];
  for (const target of iter) {
    res.push(func(target));
  }
  return res;
});

const myFilter = curry((func, iter) => {
  let res = [];
  for (const target of iter) {
    if (func(target)) {
      res.push(target);
    }
  }
  return res;
});

const myReduce = curry((func, acc, iter) => {
  if (!iter) {
    iter = acc[Symbol.iterator]();
    acc = iter.next().value;
  }
  for (const target of iter) {
    acc = func(acc, target);
  }
  return acc;
});

const go = (...args) => {
  return args.reduce((previousFunc, currentFunc) => {
    return currentFunc(previousFunc);
  });
};

const pipe = (func, ...funcs) => {
  return (...args) => {
    return go(func(...args), ...funcs);
  };
};

const total_price = pipe(
  myMap((product) => product.price),
  myReduce((a, b) => a + b)
);

const base_total_price = (predi) => pipe(myFilter(predi), total_price);

go(
  products,
  base_total_price((product) => product.price < 25000),
  console.log // 35000
);
```

<br/>
