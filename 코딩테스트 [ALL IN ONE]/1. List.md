# List

## 리스트 (List)

보통 Set 자료구조와 많이 비교된다. <br/>
Set 자료구조는 '집합'으로 인자의 담긴 순서(index)는 전혀 신경쓰지 않는다.

**List는 크게 Array-List와 Linked-List로 구성되어있다.** <br/>
파이썬에서 사용하는 자료형 리스트는 Array-List를 말하는 것.

Array-List는 다시 Array 또는 Dynamic Array로 구성된다. <br/>
이 영역부터는 C언어로 동작하는 영역.

파이썬의 Array-List는 기본적으로 Dynamic Array를 통해 동작하며 Dynamic Array는 내부적으로 Array를 소유한다.

Linked-List는 Node를 구성해서 자료구조를 생성해서 사용해야 한다.

<br/>

## 배열 (Array)

배열의 특성 <br/>

1. 고정된 저장 공간
2. 순차적인 데이터 저장

배열은 선언시에 size를 정하여 해당 size만큼 연속된 메모리를 할당 받아 data를 연속적/순차적으로 저장하는 자료구조.

<br/>

- Random(Direct) Access

'고정된 저장 공간'과 관련한 내용.

배열 변수는 자신이 할당받은 메모리의 첫 번째 주소를 가리킨다. <br/>
배열은 데이터가 연속적/순차적으로 저장되어 있기 때문에 첫 주소값만 알고 있다면, 어떤 index에도 즉시 접근이 가능하다. <br/>
따라서 임의의 데이터에 접근하는 데에 걸리는 연산의 시간복잡도는 Big-O(1) 이다.

<br/>

- Static Array 한계

데이터의 개수가 정해져있는 경우에는 static array를 사용하는 것이 효율적. <br/>
하지만 선언시에 정한 size보다 많은 데이터를 저장해야 하는 경우 공간이 부족하여 문제가 발생할 수 있음. <br/>
그렇다고 항상 큰 배열을 선언하는 것은 메모리 비효율이 발생. <br/>
이러한 문제를 해결할 수 있는 것이 Dynamic Array

<br/>

## 동적 배열 (Dynamic Array)

Static Array와 달리, 선언 이후에 size를 변경할 수 있다. <br/>
(Resizing이라는 과정을 통해서 이루어진다.)

기존의 배열보다 2배(대부분의 언어에서 타협) 큰 배열을 할당 -> 모든 데이터를 옮겨 적음 -> 기존에 있던 배열 삭제. <br/>
시간 복잡도는 Big-O(n). <br/>
(resize를 2배 큰 크기로 resize하는 행위를 더블링(Doubling)이라고 한다.)

Dynamic Array도 내부적으로는 Array로 구성되어 있다.

- Dynamic Array 사용

선언시 배열의 크기를 정하지 않아도 되기 때문에 코딩 테스트에서 Dynamic Array를 자주 사용. <br/>
Python에서는 list 자료형을 통해 Dynamic Array가 이미 구현되어 있기 때문에 이를 사용하면 된다.

우리가 알아야 할 것은 list의 연산과 시간복잡도.

<br/>

- Static Array vs Dynamic Array 시간복잡도 비교

|   operation   | Static Array | Dynamic Array  |
| :-----------: | :----------: | :------------: |
| access/update |     O(1)     |      O(1)      |
|  insert_back  |     O(1)     | amortized O(1) |
|  delete_back  |     O(1)     |      O(1)      |
|   insert_at   |     O(n)     |      O(n)      |
|   delete_at   |     O(n)     |      O(n)      |

Resizing 과정의 시간복잡도가 Big-O(n)이지만, 데이터 추가의 시간복잡도가 Big-O(n)이라고 할 수는 없다. <br/>
그래서 분할상환기법을 사용한다.

<br/>

## [코테 적용] 👉 반복문

Step 1. 문제 이해 <br/>
Step 2. 접근 방법 (가장 중요) <br/>
Step 3. 코드 설계 <br/>
Step 4. 코드 구현 <br/>

중 Step 2. 접근 방법에 대해 고찰해보도록 한다.

- 직관적으로 생각하기

  - 보통 완전탐색으로 시작
  - 문제 상황을 단순화해서 생각하기
  - 문제 상황을 극한화하여 생각하기 ()

- 자료구조와 알고리즘 활용

  - **Step 1. 문제 이해**에서 파악한 내용을 근간으로 자료구조 결정
  - 대놓고 특정 자료구조와 알고리즘을 묻는 문제도 많음
  - 자료구조에 따라 선택할 수 있는 알고리즘을 문제에 적용

- 메모리 사용

  - 시간복잡도를 줄이기 위해 메모리를 사용하는 방법
  - 대표적으로 해시테이블

<br/>

## [코테 적용] 👉 two pointer

Python에서 정렬이 되지 않은 리스트를 정렬하는데 드는 시간복잡도는 Big-O(nlogn)이다. <br/>
(기존에는 merge sort를 사용 했지만, Python 3.9 부터는 tim sort를 사용)

<br/>

> Two Pointer

리스트의 index에 대해 두가지 포인터를 두고 옮겨가며 풀이하는 방식. (정형적이진 않음) <br/>
투포인터는 보통 리스트가 정렬된 상황에서 사용된다.

~~Leet Code의 1. Two Sum 문제를 풀어보도록 하자. (완)~~

<br/>

## 연결리스트 (Linked List) - 1

<br/>

## 연결리스트 (Linked List) - 2

<br/>

## [코테 적용] 👉 연결리스트 구현 (전반부)

<br/>

## [코테 적용] 👉 연결리스트 구현 (후반부)

<br/>
